<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>线性时间查找回文串的Manacher算法 | 开发商跑路，招标中</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">线性时间查找回文串的Manacher算法</h1><a id="logo" href="/.">开发商跑路，招标中</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">线性时间查找回文串的Manacher算法</h1><div class="post-meta">Aug 5, 2020<span> | </span><span class="category"><a href="/categories/技术/">技术</a></span></div><div class="post-content"><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p>一个回文串就是正读倒读都相同的字符串如<code>ABABABA</code>。给定一个任意字符串s，要从中找出所有的回文串，最直觉的方法就是中心拓展法。即对每一个中心，都依次拓展出去，检查是否能构成回文串。注意这里的中心可能是一个字符（技术长度的情况），类似<code>ABA</code>的<code>B</code>，也可能是两个字符（偶数长度的情况），类似<code>ABBA</code>的<code>BB</code>。显然时间复杂度是O(N^2)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">non_manacher_naive</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, odd = <span class="number">0</span>, even = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i - k &gt;= <span class="number">0</span> &amp;&amp; i + k &lt; s.length() &amp;&amp; s[i + k] == s[i - k]) &#123;</span><br><span class="line">            ++k;</span><br><span class="line">        &#125;</span><br><span class="line">        odd = max(odd, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i - k &gt;= <span class="number">0</span> &amp;&amp; i + k + <span class="number">1</span> &lt; s.length() &amp;&amp; s[i - k] == s[i + k + <span class="number">1</span>]) &#123;</span><br><span class="line">            ++k;</span><br><span class="line">        &#125;</span><br><span class="line">        even = max(even, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max(odd * <span class="number">2</span> - <span class="number">1</span>, <span class="number">2</span> * even);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为最坏情况下的回文字符串个数可能达到O(N^2)，所以解法似乎不可能达到线性时间。</p>
<p>但是一如既往地，依然有神仙（Glenn K. Manacher, 1975）搞出了线性时间的算法。</p>
<p>该解法总体的思想在于利用对称性来直接跳过对称字符的验证。</p>
<p>例如有字符串<code>...BABAB...</code>，假设我们已经知道了<code>BABAB</code>是对称的，那么我们可以想见左边<code>A</code>为中心的回文串长度似乎和以右边<code>A</code>为中心的回文串有什么关系，他们都能展到<code>BAB</code>，而且很显然他们一定要有一定的对称性才能保证整个大串是对称的。</p>
<p>Manacher算法正要充分利用这一点。假如整个字符串就是<code>BABAB</code>，那么我们在判断完以左边<code>A</code>为中心的回文串是<code>BAB</code>之后，立刻就可以得知以右边的<code>A</code>的回文串也是<code>BAB</code>。</p>
<p>但是这样有一个<strong>棘手的</strong>问题，考虑字符串<code>ABABABC</code>。这时能观察到左边<code>A</code>的回文串长度为5，即<code>ABABA</code>，但是右边的<code>A</code>依然只有3，<code>BAB</code>。这样我们的办法就失效了。</p>
<p>我们来观察一下失效的原因。首先我们知道<code>BABAB</code>是对称的，那么只要其中<code>&quot;BAB&quot;AB</code>和<code>BA&quot;BAB&quot;</code>这两个<code>BAB</code>小段都完全“涵盖”在<code>BABAB</code>内，我们的对称判断就都是安全的。上面的失效，正是因为<code>&quot;ABABA&quot;BC</code>中的<code>ABABA</code>左端逃出了大回文串的覆盖范围。因此我们对于这种逃出了涵盖边界的情况，需要在对称判断之后，用朴素的拓展算法来计算以这个点为中心构成的回文串长度。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>我们“加速”主要是通过在一个大回文串下直接利用对称性来实现的，因此需要一对指针<code>l</code>, <code>r</code>，代表大串的左右位置。我们在设数组<code>d1[i]</code>表示以<code>i</code>处为中心的奇数回文串的个数，数组<code>d2[i]</code>为以<code>i</code>处为中心的偶数长度的回文串个数。知道了个数自然也就知道了长度。</p>
<p>可以写出下面两个函数，分别求<code>d1</code>和<code>d2</code>，并返回最大的长度。有二重循环，可是为什么时间复杂度是线性的？注意到，每次迭代都会使<code>r</code>的值加一，并且<code>r</code>是从不减小的。这两个性质说明最后的迭代次数会是O(N)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">odd_max_palindrome_length_manacher</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//奇数情况</span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> max_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; d1(s.size());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = i &gt; r ? <span class="number">1</span> : min(d1[l + (r - i)], r - i);<span class="comment">//k是个数</span></span><br><span class="line">        <span class="keyword">while</span> (i - k &gt;= <span class="number">0</span> &amp;&amp; i + k &lt; s.size() &amp;&amp; s[i - k] == s[i + k])</span><br><span class="line">        ++k;</span><br><span class="line">        d1[i] = k--;<span class="comment">//长度和坐标加减要错1，下面更新时要用</span></span><br><span class="line">        <span class="keyword">if</span> (i + k &gt; r) &#123;</span><br><span class="line">            <span class="comment">//超过了当前大串的范围，更新</span></span><br><span class="line">            l = i - k;</span><br><span class="line">            r = i + k;</span><br><span class="line">        &#125;</span><br><span class="line">        max_cnt = max(max_cnt, d1[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * max_cnt - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">even_max_palindrome_length_manacher</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//偶数情况</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; d2(s.size());</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">-1</span>, max_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = i &gt; r ? <span class="number">0</span> : min(r - i + <span class="number">1</span>, d2[l + r - i + <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">while</span> (i - k - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; i + k &lt; s.size() &amp;&amp; s[i - k - <span class="number">1</span>] == s[i + k])</span><br><span class="line">        ++k;</span><br><span class="line">        d2[i] = k--;</span><br><span class="line">        <span class="keyword">if</span> (i + k &gt; r) &#123;</span><br><span class="line">            l = i - k - <span class="number">1</span>;</span><br><span class="line">            r = i + k;</span><br><span class="line">        &#125;</span><br><span class="line">        max_cnt = max(max_cnt, d2[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * max_cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="统一处理"><a href="#统一处理" class="headerlink" title="统一处理"></a>统一处理</h3><p>网上能见到的Manacher算法，都会采用填充的方式，使原串变为一个奇数长度的串，如<code>ABABA</code>变为<code>#A#B#A#B#A#</code>。这样是为了一次计算出<code>d1</code>和<code>d2</code>。</p>
<p>假设原串为<code>s</code>，新串为<code>s1</code>，那么<code>s1</code>中计算出来的<code>d1[i]</code>描述的一定是一个以<code>#</code>结尾的回文串。设原串<code>s</code>中一个以字母为中心的极大回文串长度为<code>m+1</code>，填充后对应的长度即为<code>m+1 + m+2 = 2m+3</code>。类似地，原串中以“空”为中心的极大回文串长度为<code>m</code>，那么对应的<code>s1</code>中的中心点则为<code>#</code>，长度<code>2m+2</code>。<br>结论，<code>s1</code>中，<code>d1[i]</code>表示的就是在<code>s</code>中的对应中心的极大回文串的<strong>总长度+1</strong>，最后就只需要求<code>s1</code>的<code>d1</code>即可。一定要理解的话，可以这样想：首先在转换得到的字符串<code>s1</code>中，所有的回文字串的长度都为奇数，那么对于以<code>s1[i]</code>为中心的最长回文字串，其长度就为<code>2*d1[i]-1</code>,经过观察可知，<code>s1</code>中所有的回文子串，其中分隔符的数量一定比其他字符的数量多1，也就是有<code>d1[i]</code>个分隔符，剩下<code>d[i]-1</code>个字符来自原字符串，所以该回文串在原字符串中的长度就为<code>d1[i]-1</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Manacher</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回最长的长度</span></span><br><span class="line">    <span class="built_in">string</span> s1 = <span class="string">"#"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c: s) &#123;</span><br><span class="line">        s1.push_back(c);</span><br><span class="line">        s1.push_back(<span class="string">'#'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//预处理完毕</span></span><br><span class="line">    <span class="keyword">int</span> n = s1.size();</span><br><span class="line">    <span class="keyword">int</span> len_ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; d1(s1.size());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, l = <span class="number">0</span>, r = <span class="number">-1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = i &gt; r ? <span class="number">1</span> : min(r - i, d1[l + r - i]);</span><br><span class="line">        <span class="keyword">while</span> (i - k &gt;= <span class="number">0</span> &amp;&amp; i + k &lt; n &amp;&amp; s1[i - k] == s1[i + k]) &#123;</span><br><span class="line">            ++k;</span><br><span class="line">        &#125;</span><br><span class="line">        d1[i] = k--;</span><br><span class="line">        <span class="keyword">if</span> (i + k &gt; r) &#123;</span><br><span class="line">            r = i + k;</span><br><span class="line">            l = i - k;</span><br><span class="line">        &#125;</span><br><span class="line">    len_ans = max(len_ans, d1[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len_ans - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是想要直接取得字符串也不难，但是要注意区分奇偶性：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ans即为求得的回文串长度，centre是在填充字符串中的最长子串的i</span></span><br><span class="line"><span class="keyword">if</span> (ans &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        centre /= <span class="number">2</span>;</span><br><span class="line">        l = centre - ans / <span class="number">2</span>;</span><br><span class="line">        r = centre + ans / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        centre /= <span class="number">2</span>;</span><br><span class="line">        l = centre - ans / <span class="number">2</span>;</span><br><span class="line">        r = centre + ans / <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> s.substr(l, r - l + <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h3><p>简单得测算了对字符串<code>&quot;AAAA....&quot;(50000个A)</code>进行计算，单位为秒，结果显示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\mingy\Desktop\Leetcode_river_in_the_desert&gt;g++ Manacher算法.cpp &amp;&amp; a.exe</span><br><span class="line">Manacher&apos;s result: 50000</span><br><span class="line">Central expansion&apos;s result: 50000</span><br><span class="line">Manacher&apos;s duration:0.004</span><br><span class="line">Central expansion&apos;s duration:8.337</span><br></pre></td></tr></table></figure>
<p>可以看见性能差异巨大。源代码可在<a href="https://github.com/mingyunyuansu/Leetcode_river_in_the_desert/blob/master/Manacher%E7%AE%97%E6%B3%95.cpp" target="_blank" rel="noopener">这里</a>找到。</p>
</div><div class="tags"><a href="/tags/LeetCode/">LeetCode</a><a href="/tags/算法/">算法</a><a href="/tags/字符串/">字符串</a></div><div class="post-nav"><a class="pre" href="/2020/08/05/前缀函数与KMP算法/">前缀函数与KMP算法</a><a class="next" href="/2020/03/10/关于RAID类型的笔记/">关于RAID类型的笔记</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://mingyunyuansu.github.io"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/出行/">出行</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂记/">杂记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/算法/技术/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/树/">树</a></li></ul></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/中二/" style="font-size: 15px;">中二</a> <a href="/tags/LeetCode/" style="font-size: 15px;">LeetCode</a> <a href="/tags/随想/" style="font-size: 15px;">随想</a> <a href="/tags/汇编/" style="font-size: 15px;">汇编</a> <a href="/tags/笔记/" style="font-size: 15px;">笔记</a> <a href="/tags/技术/" style="font-size: 15px;">技术</a> <a href="/tags/树/" style="font-size: 15px;">树</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/求职/" style="font-size: 15px;">求职</a> <a href="/tags/数据结构与算法分析-C语言描述/" style="font-size: 15px;">数据结构与算法分析 C语言描述</a> <a href="/tags/双指针/" style="font-size: 15px;">双指针</a> <a href="/tags/大学/" style="font-size: 15px;">大学</a> <a href="/tags/信安/" style="font-size: 15px;">信安</a> <a href="/tags/运维/" style="font-size: 15px;">运维</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/面试/" style="font-size: 15px;">面试</a> <a href="/tags/留学/" style="font-size: 15px;">留学</a> <a href="/tags/编程能力/" style="font-size: 15px;">编程能力</a> <a href="/tags/White-Album-2/" style="font-size: 15px;">White Album 2</a> <a href="/tags/实验/" style="font-size: 15px;">实验</a> <a href="/tags/黑魔法/" style="font-size: 15px;">黑魔法</a> <a href="/tags/学习/" style="font-size: 15px;">学习</a> <a href="/tags/电影/" style="font-size: 15px;">电影</a> <a href="/tags/字符串/" style="font-size: 15px;">字符串</a> <a href="/tags/OI/" style="font-size: 15px;">OI</a> <a href="/tags/台湾/" style="font-size: 15px;">台湾</a> <a href="/tags/游记/" style="font-size: 15px;">游记</a> <a href="/tags/性/" style="font-size: 15px;">性</a> <a href="/tags/社交/" style="font-size: 15px;">社交</a> <a href="/tags/语言/" style="font-size: 15px;">语言</a> <a href="/tags/洛谷/" style="font-size: 15px;">洛谷</a> <a href="/tags/游戏/" style="font-size: 15px;">游戏</a> <a href="/tags/读书/" style="font-size: 15px;">读书</a> <a href="/tags/网络/" style="font-size: 15px;">网络</a> <a href="/tags/抑郁症/" style="font-size: 15px;">抑郁症</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/11/30/内存对齐和#pragma pack/">内存对齐和pragma pack指令的计算方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/13/手动实现next_permutation/">手动实现next_permutation</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/10/快速排序的竞赛实现/">快速排序的竞赛实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/17/【网易面试题】二人等价值均分一堆物品后丢弃的最小价值/">【网易面试题】二人等价值均分一堆物品后丢弃的最小价值</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/05/前缀函数与KMP算法/">前缀函数与KMP算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/05/线性时间查找回文串的Manacher算法/">线性时间查找回文串的Manacher算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/10/关于RAID类型的笔记/">关于RAID类型的笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/08/SYN Flood洪水攻击/">SYN Flood洪水攻击</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/07/Linux后台，&, disown, nohup之区别/">Linux后台进程，&, disown, nohup之区别</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/03/Construct Binary Tree from Preorder and Inorder Traversal/">Construct Binary Tree from Preorder and Inorder Traversal</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">开发商跑路，招标中.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>